/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SDKHooks } from "../hooks/hooks.js";
import { SDK_METADATA, SDKOptions, serverURLFromOptions } from "../lib/config.js";
import {
    encodeFormQuery as encodeFormQuery$,
    encodeJSON as encodeJSON$,
    encodeSimple as encodeSimple$,
} from "../lib/encodings.js";
import { HTTPClient } from "../lib/http.js";
import * as schemas$ from "../lib/schemas.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as errors from "../models/errors/index.js";
import * as operations from "../models/operations/index.js";
import * as z from "zod";

export class Links extends ClientSDK {
    private readonly options$: SDKOptions & { hooks?: SDKHooks };

    constructor(options: SDKOptions = {}) {
        const opt = options as unknown;
        let hooks: SDKHooks;
        if (
            typeof opt === "object" &&
            opt != null &&
            "hooks" in opt &&
            opt.hooks instanceof SDKHooks
        ) {
            hooks = opt.hooks;
        } else {
            hooks = new SDKHooks();
        }

        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
            hooks,
        });

        this.options$ = { ...options, hooks };
        void this.options$;
    }

    /**
     * Retrieve a list of links
     *
     * @remarks
     * Retrieve a list of links for the authenticated workspace. The list will be paginated and the provided query parameters allow filtering the returned links.
     */
    async list(
        request?: operations.GetLinksRequest | undefined,
        options?: RequestOptions
    ): Promise<Array<components.LinkSchema>> {
        const input$ = typeof request === "undefined" ? {} : request;
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GetLinksRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/links")();

        const query$ = encodeFormQuery$({
            domain: payload$.domain,
            page: payload$.page,
            projectSlug: this.options$.projectSlug,
            search: payload$.search,
            showArchived: payload$.showArchived,
            sort: payload$.sort,
            tagId: payload$.tagId,
            tagIds: payload$.tagIds,
            tagNames: payload$.tagNames,
            userId: payload$.userId,
            withTags: payload$.withTags,
            workspaceId: this.options$.workspaceId,
        });

        let security$;
        if (typeof this.options$.token === "function") {
            security$ = { token: await this.options$.token() };
        } else if (this.options$.token) {
            security$ = { token: this.options$.token };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "getLinks",
            oAuth2Scopes: [],
            securitySource: this.options$.token,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = {
            context,
            errorCodes: [
                "400",
                "401",
                "403",
                "404",
                "409",
                "410",
                "422",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
        };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<Array<components.LinkSchema>>()
            .json(200, z.array(components.LinkSchema$.inboundSchema))
            .json(400, errors.BadRequest$, { err: true })
            .json(401, errors.Unauthorized$, { err: true })
            .json(403, errors.Forbidden$, { err: true })
            .json(404, errors.NotFound$, { err: true })
            .json(409, errors.Conflict$, { err: true })
            .json(410, errors.InviteExpired$, { err: true })
            .json(422, errors.UnprocessableEntity$, { err: true })
            .json(429, errors.RateLimitExceeded$, { err: true })
            .fail(["4XX", "5XX"])
            .json(500, errors.InternalServerError$, { err: true })
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Create a new link
     *
     * @remarks
     * Create a new link for the authenticated workspace.
     */
    async create(
        request?: operations.CreateLinkRequestBody | undefined,
        options?: RequestOptions
    ): Promise<components.LinkSchema> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.CreateLinkRequestBody$.outboundSchema.optional().parse(value$),
            "Input validation failed"
        );
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/links")();

        const query$ = encodeFormQuery$({
            projectSlug: this.options$.projectSlug,
            workspaceId: this.options$.workspaceId,
        });

        let security$;
        if (typeof this.options$.token === "function") {
            security$ = { token: await this.options$.token() };
        } else if (this.options$.token) {
            security$ = { token: this.options$.token };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "createLink",
            oAuth2Scopes: [],
            securitySource: this.options$.token,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = {
            context,
            errorCodes: [
                "400",
                "401",
                "403",
                "404",
                "409",
                "410",
                "422",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
        };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<components.LinkSchema>()
            .json(200, components.LinkSchema$)
            .json(400, errors.BadRequest$, { err: true })
            .json(401, errors.Unauthorized$, { err: true })
            .json(403, errors.Forbidden$, { err: true })
            .json(404, errors.NotFound$, { err: true })
            .json(409, errors.Conflict$, { err: true })
            .json(410, errors.InviteExpired$, { err: true })
            .json(422, errors.UnprocessableEntity$, { err: true })
            .json(429, errors.RateLimitExceeded$, { err: true })
            .fail(["4XX", "5XX"])
            .json(500, errors.InternalServerError$, { err: true })
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Retrieve the number of links
     *
     * @remarks
     * Retrieve the number of links for the authenticated workspace. The provided query parameters allow filtering the returned links.
     */
    async count(
        request?: operations.GetLinksCountRequest | undefined,
        options?: RequestOptions
    ): Promise<number> {
        const input$ = typeof request === "undefined" ? {} : request;
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GetLinksCountRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/links/count")();

        const query$ = encodeFormQuery$({
            domain: payload$.domain,
            groupBy: payload$.groupBy,
            projectSlug: this.options$.projectSlug,
            search: payload$.search,
            showArchived: payload$.showArchived,
            tagId: payload$.tagId,
            tagIds: payload$.tagIds,
            tagNames: payload$.tagNames,
            userId: payload$.userId,
            withTags: payload$.withTags,
            workspaceId: this.options$.workspaceId,
        });

        let security$;
        if (typeof this.options$.token === "function") {
            security$ = { token: await this.options$.token() };
        } else if (this.options$.token) {
            security$ = { token: this.options$.token };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "getLinksCount",
            oAuth2Scopes: [],
            securitySource: this.options$.token,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = {
            context,
            errorCodes: [
                "400",
                "401",
                "403",
                "404",
                "409",
                "410",
                "422",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
        };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<number>()
            .json(200, z.number())
            .json(400, errors.BadRequest$, { err: true })
            .json(401, errors.Unauthorized$, { err: true })
            .json(403, errors.Forbidden$, { err: true })
            .json(404, errors.NotFound$, { err: true })
            .json(409, errors.Conflict$, { err: true })
            .json(410, errors.InviteExpired$, { err: true })
            .json(422, errors.UnprocessableEntity$, { err: true })
            .json(429, errors.RateLimitExceeded$, { err: true })
            .fail(["4XX", "5XX"])
            .json(500, errors.InternalServerError$, { err: true })
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Retrieve a link
     *
     * @remarks
     * Retrieve the info for a link.
     */
    async get(
        request?: operations.GetLinkInfoRequest | undefined,
        options?: RequestOptions
    ): Promise<components.LinkSchema> {
        const input$ = typeof request === "undefined" ? {} : request;
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GetLinkInfoRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/links/info")();

        const query$ = encodeFormQuery$({
            domain: payload$.domain,
            externalId: payload$.externalId,
            key: payload$.key,
            linkId: payload$.linkId,
            projectSlug: this.options$.projectSlug,
            workspaceId: this.options$.workspaceId,
        });

        let security$;
        if (typeof this.options$.token === "function") {
            security$ = { token: await this.options$.token() };
        } else if (this.options$.token) {
            security$ = { token: this.options$.token };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "getLinkInfo",
            oAuth2Scopes: [],
            securitySource: this.options$.token,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = {
            context,
            errorCodes: [
                "400",
                "401",
                "403",
                "404",
                "409",
                "410",
                "422",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
        };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<components.LinkSchema>()
            .json(200, components.LinkSchema$)
            .json(400, errors.BadRequest$, { err: true })
            .json(401, errors.Unauthorized$, { err: true })
            .json(403, errors.Forbidden$, { err: true })
            .json(404, errors.NotFound$, { err: true })
            .json(409, errors.Conflict$, { err: true })
            .json(410, errors.InviteExpired$, { err: true })
            .json(422, errors.UnprocessableEntity$, { err: true })
            .json(429, errors.RateLimitExceeded$, { err: true })
            .fail(["4XX", "5XX"])
            .json(500, errors.InternalServerError$, { err: true })
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Delete a link
     *
     * @remarks
     * Delete a link for the authenticated workspace.
     */
    async delete(
        linkId: string,
        options?: RequestOptions
    ): Promise<operations.DeleteLinkResponseBody> {
        const input$: operations.DeleteLinkRequest = {
            linkId: linkId,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.DeleteLinkRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            linkId: encodeSimple$("linkId", payload$.linkId, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/links/{linkId}")(pathParams$);

        const query$ = encodeFormQuery$({
            projectSlug: this.options$.projectSlug,
            workspaceId: this.options$.workspaceId,
        });

        let security$;
        if (typeof this.options$.token === "function") {
            security$ = { token: await this.options$.token() };
        } else if (this.options$.token) {
            security$ = { token: this.options$.token };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "deleteLink",
            oAuth2Scopes: [],
            securitySource: this.options$.token,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = {
            context,
            errorCodes: [
                "400",
                "401",
                "403",
                "404",
                "409",
                "410",
                "422",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
        };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.DeleteLinkResponseBody>()
            .json(200, operations.DeleteLinkResponseBody$)
            .json(400, errors.BadRequest$, { err: true })
            .json(401, errors.Unauthorized$, { err: true })
            .json(403, errors.Forbidden$, { err: true })
            .json(404, errors.NotFound$, { err: true })
            .json(409, errors.Conflict$, { err: true })
            .json(410, errors.InviteExpired$, { err: true })
            .json(422, errors.UnprocessableEntity$, { err: true })
            .json(429, errors.RateLimitExceeded$, { err: true })
            .fail(["4XX", "5XX"])
            .json(500, errors.InternalServerError$, { err: true })
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Update a link
     *
     * @remarks
     * Update a link for the authenticated workspace. If there's no change, returns it as it is.
     */
    async update(
        linkId: string,
        requestBody?: operations.UpdateLinkRequestBody | undefined,
        options?: RequestOptions
    ): Promise<components.LinkSchema> {
        const input$: operations.UpdateLinkRequest = {
            linkId: linkId,
            requestBody: requestBody,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.UpdateLinkRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.RequestBody, { explode: true });

        const pathParams$ = {
            linkId: encodeSimple$("linkId", payload$.linkId, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/links/{linkId}")(pathParams$);

        const query$ = encodeFormQuery$({
            projectSlug: this.options$.projectSlug,
            workspaceId: this.options$.workspaceId,
        });

        let security$;
        if (typeof this.options$.token === "function") {
            security$ = { token: await this.options$.token() };
        } else if (this.options$.token) {
            security$ = { token: this.options$.token };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "updateLink",
            oAuth2Scopes: [],
            securitySource: this.options$.token,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = {
            context,
            errorCodes: [
                "400",
                "401",
                "403",
                "404",
                "409",
                "410",
                "422",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
        };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<components.LinkSchema>()
            .json(200, components.LinkSchema$)
            .json(400, errors.BadRequest$, { err: true })
            .json(401, errors.Unauthorized$, { err: true })
            .json(403, errors.Forbidden$, { err: true })
            .json(404, errors.NotFound$, { err: true })
            .json(409, errors.Conflict$, { err: true })
            .json(410, errors.InviteExpired$, { err: true })
            .json(422, errors.UnprocessableEntity$, { err: true })
            .json(429, errors.RateLimitExceeded$, { err: true })
            .fail(["4XX", "5XX"])
            .json(500, errors.InternalServerError$, { err: true })
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Bulk create links
     *
     * @remarks
     * Bulk create up to 100 links for the authenticated workspace.
     */
    async createMany(
        request?: Array<operations.RequestBody> | undefined,
        options?: RequestOptions
    ): Promise<Array<components.LinkSchema>> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.array(operations.RequestBody$.outboundSchema).optional().parse(value$),
            "Input validation failed"
        );
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/links/bulk")();

        const query$ = encodeFormQuery$({
            projectSlug: this.options$.projectSlug,
            workspaceId: this.options$.workspaceId,
        });

        let security$;
        if (typeof this.options$.token === "function") {
            security$ = { token: await this.options$.token() };
        } else if (this.options$.token) {
            security$ = { token: this.options$.token };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "bulkCreateLinks",
            oAuth2Scopes: [],
            securitySource: this.options$.token,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = {
            context,
            errorCodes: [
                "400",
                "401",
                "403",
                "404",
                "409",
                "410",
                "422",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
        };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<Array<components.LinkSchema>>()
            .json(200, z.array(components.LinkSchema$.inboundSchema))
            .json(400, errors.BadRequest$, { err: true })
            .json(401, errors.Unauthorized$, { err: true })
            .json(403, errors.Forbidden$, { err: true })
            .json(404, errors.NotFound$, { err: true })
            .json(409, errors.Conflict$, { err: true })
            .json(410, errors.InviteExpired$, { err: true })
            .json(422, errors.UnprocessableEntity$, { err: true })
            .json(429, errors.RateLimitExceeded$, { err: true })
            .fail(["4XX", "5XX"])
            .json(500, errors.InternalServerError$, { err: true })
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Upsert a link
     *
     * @remarks
     * Upsert a link for the authenticated workspace by its URL. If a link with the same URL already exists, return it (or update it if there are any changes). Otherwise, a new link will be created.
     */
    async upsert(
        request?: operations.UpsertLinkRequestBody | undefined,
        options?: RequestOptions
    ): Promise<components.LinkSchema> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.UpsertLinkRequestBody$.outboundSchema.optional().parse(value$),
            "Input validation failed"
        );
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/links/upsert")();

        const query$ = encodeFormQuery$({
            projectSlug: this.options$.projectSlug,
            workspaceId: this.options$.workspaceId,
        });

        let security$;
        if (typeof this.options$.token === "function") {
            security$ = { token: await this.options$.token() };
        } else if (this.options$.token) {
            security$ = { token: this.options$.token };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "upsertLink",
            oAuth2Scopes: [],
            securitySource: this.options$.token,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = {
            context,
            errorCodes: [
                "400",
                "401",
                "403",
                "404",
                "409",
                "410",
                "422",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
        };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<components.LinkSchema>()
            .json(200, components.LinkSchema$)
            .json(400, errors.BadRequest$, { err: true })
            .json(401, errors.Unauthorized$, { err: true })
            .json(403, errors.Forbidden$, { err: true })
            .json(404, errors.NotFound$, { err: true })
            .json(409, errors.Conflict$, { err: true })
            .json(410, errors.InviteExpired$, { err: true })
            .json(422, errors.UnprocessableEntity$, { err: true })
            .json(429, errors.RateLimitExceeded$, { err: true })
            .fail(["4XX", "5XX"])
            .json(500, errors.InternalServerError$, { err: true })
            .match(response, { extraFields: responseFields$ });

        return result$;
    }
}
